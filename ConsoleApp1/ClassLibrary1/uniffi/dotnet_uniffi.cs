// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.8.3+v0.25.0
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable




using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
namespace uniffi.dotnet_uniffi;



// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer {
    public int capacity;
    public int len;
    public IntPtr data;

    public static RustBuffer Alloc(int size) {
        return _UniffiHelpers.RustCall((ref RustCallStatus status) => {
            var buffer = _UniFFILib.ffi_dotnet_uniffi_rustbuffer_alloc(size, ref status);
            if (buffer.data == IntPtr.Zero) {
                throw new AllocationException($"RustBuffer.Alloc() returned null data pointer (size={size})");
            }
            return buffer;
        });
    }

    public static void Free(RustBuffer buffer) {
        _UniffiHelpers.RustCall((ref RustCallStatus status) => {
            _UniFFILib.ffi_dotnet_uniffi_rustbuffer_free(buffer, ref status);
        });
    }

    public static BigEndianStream MemoryStream(IntPtr data, int length) {
        unsafe {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
        }
    }

    public BigEndianStream AsStream() {
        unsafe {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), len));
        }
    }

    public BigEndianStream AsWriteableStream() {
        unsafe {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), capacity, capacity, FileAccess.Write));
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes {
    public int length;
    public IntPtr data;
}


// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType> {
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value) {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToInt32(stream.Position);
            return rbuf;
        } catch {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf) {
        var stream = rbuf.AsStream();
        try {
           var item = Read(stream);
           if (stream.HasRemaining()) {
               throw new InternalException("junk remaining in buffer after lifting, something is very wrong!!");
           }
           return item;
        } finally {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType>: FfiConverter<CsType, RustBuffer> {
    public override CsType Lift(RustBuffer value) {
        return LiftFromRustBuffer(value);
    }
    public override RustBuffer Lower(CsType value) {
        return LowerIntoRustBuffer(value);
    }
}


// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct RustCallStatus {
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess() {
        return code == 0;
    }

    public bool IsError() {
        return code == 1;
    }

    public bool IsPanic() {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
public class UniffiException: Exception {
    public UniffiException(): base() {}
    public UniffiException(string message): base(message) {}
}

public class UndeclaredErrorException: UniffiException {
    public UndeclaredErrorException(string message): base(message) {}
}

public class PanicException: UniffiException {
    public PanicException(string message): base(message) {}
}

public class AllocationException: UniffiException {
    public AllocationException(string message): base(message) {}
}

public class InternalException: UniffiException {
    public InternalException(string message): base(message) {}
}

public class InvalidEnumException: InternalException {
    public InvalidEnumException(string message): base(message) {
    }
}

public class UniffiContractVersionException: UniffiException {
    public UniffiContractVersionException(string message): base(message) {
    }
}

public class UniffiContractChecksumException: UniffiException {
    public UniffiContractChecksumException(string message): base(message) {
    }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> where E: Exception {
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler: CallStatusErrorHandler<UniffiException> {
    public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf) {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException("library has returned an error not declared in UNIFFI interface file");
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers {
    public delegate void RustCallAction(ref RustCallStatus status);
    public delegate U RustCallFunc<out U>(ref RustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(CallStatusErrorHandler<E> errorHandler, RustCallFunc<U> callback)
        where E: UniffiException
    {
        var status = new RustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess()) {
            return return_value;
        } else if (status.IsError()) {
            throw errorHandler.Lift(status.error_buf);
        } else if (status.IsPanic()) {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0) {
                throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
            } else {
                throw new PanicException("Rust panic");
            }
        } else {
            throw new InternalException($"Unknown rust call status: {status.code}");
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(CallStatusErrorHandler<E> errorHandler, RustCallAction callback)
        where E: UniffiException
    {
        _UniffiHelpers.RustCallWithError(errorHandler, (ref RustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback) {
        return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback) {
        _UniffiHelpers.RustCall((ref RustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }
}


// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException: Exception {
    public StreamUnderflowException() {
    }
}

class BigEndianStream {
    Stream stream;
    public BigEndianStream(Stream stream) {
        this.stream = stream;
    }

    public bool HasRemaining() {
        return (stream.Length - stream.Position) > 0;
    }

    public long Position {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] value) {
        stream.Write(value, 0, value.Length);
    }

    public void WriteByte(byte value) {
        stream.WriteByte(value);
    }

    public void WriteUShort(ushort value) {
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteUInt(uint value) {
        stream.WriteByte((byte)(value >> 24));
        stream.WriteByte((byte)(value >> 16));
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteULong(ulong value) {
        WriteUInt((uint)(value >> 32));
        WriteUInt((uint)value);
    }

    public void WriteSByte(sbyte value) {
        stream.WriteByte((byte)value);
    }

    public void WriteShort(short value) {
        WriteUShort((ushort)value);
    }

    public void WriteInt(int value) {
        WriteUInt((uint)value);
    }

    public void WriteFloat(float value) {
        unsafe {
            WriteInt(*((int*)&value));
        }
    }

    public void WriteLong(long value) {
        WriteULong((ulong)value);
    }

    public void WriteDouble(double value) {
        WriteLong(BitConverter.DoubleToInt64Bits(value));
    }

    public byte[] ReadBytes(int length) {
        CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte() {
        CheckRemaining(1);
        return Convert.ToByte(stream.ReadByte());
    }

    public ushort ReadUShort() {
        CheckRemaining(2);
        return (ushort)(stream.ReadByte() << 8 | stream.ReadByte());
    }

    public uint ReadUInt() {
        CheckRemaining(4);
        return (uint)(stream.ReadByte() << 24
            | stream.ReadByte() << 16
            | stream.ReadByte() << 8
            | stream.ReadByte());
    }

    public ulong ReadULong() {
        return (ulong)ReadUInt() << 32 | (ulong)ReadUInt();
    }

    public sbyte ReadSByte() {
        return (sbyte)ReadByte();
    }

    public short ReadShort() {
        return (short)ReadUShort();
    }

    public int ReadInt() {
        return (int)ReadUInt();
    }

    public float ReadFloat() {
        unsafe {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong() {
        return (long)ReadULong();
    }

    public double ReadDouble() {
        return BitConverter.Int64BitsToDouble(ReadLong());
    }

    private void CheckRemaining(int length) {
        if (stream.Length - stream.Position < length) {
            throw new StreamUnderflowException();
        }
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.


// This is an implementation detail which will be called internally by the public API.
static class _UniFFILib {
    static _UniFFILib() {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();
        
        }

    [DllImport("dotnet_uniffi")]
    public static extern int uniffi_dotnet_uniffi_fn_func_add(int @a,int @b,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern RustBuffer uniffi_dotnet_uniffi_fn_func_compute(RustBuffer @value,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern RustBuffer uniffi_dotnet_uniffi_fn_func_compute_all(RustBuffer @value,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern long uniffi_dotnet_uniffi_fn_func_factorial(long @num,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern RustBuffer uniffi_dotnet_uniffi_fn_func_get_factorial(long @num,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern long uniffi_dotnet_uniffi_fn_func_last(RustBuffer @num,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern int uniffi_dotnet_uniffi_fn_func_mul(int @a,int @b,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern int uniffi_dotnet_uniffi_fn_func_sub(int @a,int @b,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern int uniffi_dotnet_uniffi_fn_func_test(int @num,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void uniffi_dotnet_uniffi_fn_func_test_panic(ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern RustBuffer uniffi_dotnet_uniffi_fn_func_test_str(RustBuffer @num,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern sbyte uniffi_dotnet_uniffi_fn_func_valid(RustBuffer @value,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern RustBuffer ffi_dotnet_uniffi_rustbuffer_alloc(int @size,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern RustBuffer ffi_dotnet_uniffi_rustbuffer_from_bytes(ForeignBytes @bytes,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rustbuffer_free(RustBuffer @buf,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern RustBuffer ffi_dotnet_uniffi_rustbuffer_reserve(RustBuffer @buf,int @additional,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_continuation_callback_set(IntPtr @callback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_u8(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_u8(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_u8(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern byte ffi_dotnet_uniffi_rust_future_complete_u8(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_i8(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_i8(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_i8(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern sbyte ffi_dotnet_uniffi_rust_future_complete_i8(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_u16(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_u16(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_u16(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort ffi_dotnet_uniffi_rust_future_complete_u16(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_i16(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_i16(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_i16(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern short ffi_dotnet_uniffi_rust_future_complete_i16(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_u32(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_u32(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_u32(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern uint ffi_dotnet_uniffi_rust_future_complete_u32(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_i32(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_i32(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_i32(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern int ffi_dotnet_uniffi_rust_future_complete_i32(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_u64(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_u64(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_u64(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern ulong ffi_dotnet_uniffi_rust_future_complete_u64(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_i64(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_i64(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_i64(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern long ffi_dotnet_uniffi_rust_future_complete_i64(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_f32(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_f32(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_f32(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern float ffi_dotnet_uniffi_rust_future_complete_f32(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_f64(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_f64(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_f64(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern double ffi_dotnet_uniffi_rust_future_complete_f64(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_pointer(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_pointer(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_pointer(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern SafeHandle ffi_dotnet_uniffi_rust_future_complete_pointer(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_rust_buffer(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_rust_buffer(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_rust_buffer(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern RustBuffer ffi_dotnet_uniffi_rust_future_complete_rust_buffer(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_poll_void(IntPtr @handle,IntPtr @uniffiCallback
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_cancel_void(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_free_void(IntPtr @handle
    );

    [DllImport("dotnet_uniffi")]
    public static extern void ffi_dotnet_uniffi_rust_future_complete_void(IntPtr @handle,ref RustCallStatus _uniffi_out_err
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort uniffi_dotnet_uniffi_checksum_func_add(
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort uniffi_dotnet_uniffi_checksum_func_compute(
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort uniffi_dotnet_uniffi_checksum_func_compute_all(
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort uniffi_dotnet_uniffi_checksum_func_factorial(
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort uniffi_dotnet_uniffi_checksum_func_get_factorial(
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort uniffi_dotnet_uniffi_checksum_func_last(
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort uniffi_dotnet_uniffi_checksum_func_mul(
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort uniffi_dotnet_uniffi_checksum_func_sub(
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort uniffi_dotnet_uniffi_checksum_func_test(
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort uniffi_dotnet_uniffi_checksum_func_test_panic(
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort uniffi_dotnet_uniffi_checksum_func_test_str(
    );

    [DllImport("dotnet_uniffi")]
    public static extern ushort uniffi_dotnet_uniffi_checksum_func_valid(
    );

    [DllImport("dotnet_uniffi")]
    public static extern uint ffi_dotnet_uniffi_uniffi_contract_version(
    );

    

    static void uniffiCheckContractApiVersion() {
        var scaffolding_contract_version = _UniFFILib.ffi_dotnet_uniffi_uniffi_contract_version();
        if (24 != scaffolding_contract_version) {
            throw new UniffiContractVersionException($"uniffi.dotnet_uniffi: uniffi bindings expected version `24`, library returned `{scaffolding_contract_version}`");
        }
    }

    static void uniffiCheckApiChecksums() {
        {
            var checksum = _UniFFILib.uniffi_dotnet_uniffi_checksum_func_add();
            if (checksum != 13040) {
                throw new UniffiContractChecksumException($"uniffi.dotnet_uniffi: uniffi bindings expected function `uniffi_dotnet_uniffi_checksum_func_add` checksum `13040`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dotnet_uniffi_checksum_func_compute();
            if (checksum != 63951) {
                throw new UniffiContractChecksumException($"uniffi.dotnet_uniffi: uniffi bindings expected function `uniffi_dotnet_uniffi_checksum_func_compute` checksum `63951`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dotnet_uniffi_checksum_func_compute_all();
            if (checksum != 63762) {
                throw new UniffiContractChecksumException($"uniffi.dotnet_uniffi: uniffi bindings expected function `uniffi_dotnet_uniffi_checksum_func_compute_all` checksum `63762`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dotnet_uniffi_checksum_func_factorial();
            if (checksum != 13353) {
                throw new UniffiContractChecksumException($"uniffi.dotnet_uniffi: uniffi bindings expected function `uniffi_dotnet_uniffi_checksum_func_factorial` checksum `13353`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dotnet_uniffi_checksum_func_get_factorial();
            if (checksum != 26933) {
                throw new UniffiContractChecksumException($"uniffi.dotnet_uniffi: uniffi bindings expected function `uniffi_dotnet_uniffi_checksum_func_get_factorial` checksum `26933`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dotnet_uniffi_checksum_func_last();
            if (checksum != 19403) {
                throw new UniffiContractChecksumException($"uniffi.dotnet_uniffi: uniffi bindings expected function `uniffi_dotnet_uniffi_checksum_func_last` checksum `19403`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dotnet_uniffi_checksum_func_mul();
            if (checksum != 1705) {
                throw new UniffiContractChecksumException($"uniffi.dotnet_uniffi: uniffi bindings expected function `uniffi_dotnet_uniffi_checksum_func_mul` checksum `1705`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dotnet_uniffi_checksum_func_sub();
            if (checksum != 9573) {
                throw new UniffiContractChecksumException($"uniffi.dotnet_uniffi: uniffi bindings expected function `uniffi_dotnet_uniffi_checksum_func_sub` checksum `9573`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dotnet_uniffi_checksum_func_test();
            if (checksum != 34844) {
                throw new UniffiContractChecksumException($"uniffi.dotnet_uniffi: uniffi bindings expected function `uniffi_dotnet_uniffi_checksum_func_test` checksum `34844`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dotnet_uniffi_checksum_func_test_panic();
            if (checksum != 52521) {
                throw new UniffiContractChecksumException($"uniffi.dotnet_uniffi: uniffi bindings expected function `uniffi_dotnet_uniffi_checksum_func_test_panic` checksum `52521`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dotnet_uniffi_checksum_func_test_str();
            if (checksum != 2099) {
                throw new UniffiContractChecksumException($"uniffi.dotnet_uniffi: uniffi bindings expected function `uniffi_dotnet_uniffi_checksum_func_test_str` checksum `2099`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_dotnet_uniffi_checksum_func_valid();
            if (checksum != 18431) {
                throw new UniffiContractChecksumException($"uniffi.dotnet_uniffi: uniffi bindings expected function `uniffi_dotnet_uniffi_checksum_func_valid` checksum `18431`, library returned `{checksum}`");
            }
        }
    }
}

// Public interface members begin here.

#pragma warning disable 8625




class FfiConverterInt32: FfiConverter<int, int> {
    public static FfiConverterInt32 INSTANCE = new FfiConverterInt32();

    public override int Lift(int value) {
        return value;
    }

    public override int Read(BigEndianStream stream) {
        return stream.ReadInt();
    }

    public override int Lower(int value) {
        return value;
    }

    public override int AllocationSize(int value) {
        return 4;
    }

    public override void Write(int value, BigEndianStream stream) {
        stream.WriteInt(value);
    }
}



class FfiConverterInt64: FfiConverter<long, long> {
    public static FfiConverterInt64 INSTANCE = new FfiConverterInt64();

    public override long Lift(long value) {
        return value;
    }

    public override long Read(BigEndianStream stream) {
        return stream.ReadLong();
    }

    public override long Lower(long value) {
        return value;
    }

    public override int AllocationSize(long value) {
        return 8;
    }

    public override void Write(long value, BigEndianStream stream) {
        stream.WriteLong(value);
    }
}



class FfiConverterBoolean: FfiConverter<bool, sbyte> {
    public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

    public override bool Lift(sbyte value) {
        return value != 0;
    }

    public override bool Read(BigEndianStream stream) {
        return Lift(stream.ReadSByte());
    }

    public override sbyte Lower(bool value) {
        return value ? (sbyte)1 : (sbyte)0;
    }

    public override int AllocationSize(bool value) {
        return (sbyte)1;
    }

    public override void Write(bool value, BigEndianStream stream) {
        stream.WriteSByte(Lower(value));
    }
}



class FfiConverterString: FfiConverter<string, RustBuffer> {
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value) {
        try {
            var bytes = value.AsStream().ReadBytes(value.len);
            return System.Text.Encoding.UTF8.GetString(bytes);
        } finally {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value) {
        const int sizeForLength = 4;
        var sizeForString = value.Length * 3;
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}




class FfiConverterDuration: FfiConverterRustBuffer<TimeSpan> {
    public static FfiConverterDuration INSTANCE = new FfiConverterDuration();

    // https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/TimeSpan.cs
    private const uint NanosecondsPerTick = 100;

    public override TimeSpan Read(BigEndianStream stream) {
        var seconds = stream.ReadULong();
        var nanoseconds = stream.ReadUInt();
        var ticks = seconds * TimeSpan.TicksPerSecond;
        ticks += nanoseconds / NanosecondsPerTick;
        return new TimeSpan(Convert.ToInt64(ticks));
    }

    public override int AllocationSize(TimeSpan value) {
        // 8 bytes for seconds, 4 bytes for nanoseconds
        return 12;
    }

    public override void Write(TimeSpan value, BigEndianStream stream) {
        stream.WriteULong(Convert.ToUInt64(value.Ticks / TimeSpan.TicksPerSecond));
        stream.WriteUInt(Convert.ToUInt32(value.Ticks % TimeSpan.TicksPerSecond * NanosecondsPerTick));
    }
}



public record ComputationRequest (
    long @value
) {
}

class FfiConverterTypeComputationRequest: FfiConverterRustBuffer<ComputationRequest> {
    public static FfiConverterTypeComputationRequest INSTANCE = new FfiConverterTypeComputationRequest();

    public override ComputationRequest Read(BigEndianStream stream) {
        return new ComputationRequest(
            @value: FfiConverterInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ComputationRequest value) {
        return
            FfiConverterInt64.INSTANCE.AllocationSize(value.@value);
    }

    public override void Write(ComputationRequest value, BigEndianStream stream) {
            FfiConverterInt64.INSTANCE.Write(value.@value, stream);
    }
}



public record ComputationResult (
    long @value, 
    TimeSpan @computationTime
) {
}

class FfiConverterTypeComputationResult: FfiConverterRustBuffer<ComputationResult> {
    public static FfiConverterTypeComputationResult INSTANCE = new FfiConverterTypeComputationResult();

    public override ComputationResult Read(BigEndianStream stream) {
        return new ComputationResult(
            @value: FfiConverterInt64.INSTANCE.Read(stream),
            @computationTime: FfiConverterDuration.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ComputationResult value) {
        return
            FfiConverterInt64.INSTANCE.AllocationSize(value.@value) +
            FfiConverterDuration.INSTANCE.AllocationSize(value.@computationTime);
    }

    public override void Write(ComputationResult value, BigEndianStream stream) {
            FfiConverterInt64.INSTANCE.Write(value.@value, stream);
            FfiConverterDuration.INSTANCE.Write(value.@computationTime, stream);
    }
}




class FfiConverterSequenceInt64: FfiConverterRustBuffer<List<long>> {
    public static FfiConverterSequenceInt64 INSTANCE = new FfiConverterSequenceInt64();

    public override List<long> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<long>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterInt64.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<long> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterInt64.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<long> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterInt64.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeComputationRequest: FfiConverterRustBuffer<List<ComputationRequest>> {
    public static FfiConverterSequenceTypeComputationRequest INSTANCE = new FfiConverterSequenceTypeComputationRequest();

    public override List<ComputationRequest> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<ComputationRequest>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeComputationRequest.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<ComputationRequest> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeComputationRequest.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<ComputationRequest> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeComputationRequest.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeComputationResult: FfiConverterRustBuffer<List<ComputationResult>> {
    public static FfiConverterSequenceTypeComputationResult INSTANCE = new FfiConverterSequenceTypeComputationResult();

    public override List<ComputationResult> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<ComputationResult>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeComputationResult.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<ComputationResult> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeComputationResult.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<ComputationResult> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeComputationResult.INSTANCE.Write(item, stream));
    }
}
#pragma warning restore 8625
public static class DotnetUniffiMethods {
    public static int Add(int @a, int @b) {
        return FfiConverterInt32.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref RustCallStatus _status) =>
    _UniFFILib.uniffi_dotnet_uniffi_fn_func_add(FfiConverterInt32.INSTANCE.Lower(@a), FfiConverterInt32.INSTANCE.Lower(@b), ref _status)
));
    }

    public static ComputationResult Compute(ComputationRequest @value) {
        return FfiConverterTypeComputationResult.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref RustCallStatus _status) =>
    _UniFFILib.uniffi_dotnet_uniffi_fn_func_compute(FfiConverterTypeComputationRequest.INSTANCE.Lower(@value), ref _status)
));
    }

    public static List<ComputationResult> ComputeAll(List<ComputationRequest> @value) {
        return FfiConverterSequenceTypeComputationResult.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref RustCallStatus _status) =>
    _UniFFILib.uniffi_dotnet_uniffi_fn_func_compute_all(FfiConverterSequenceTypeComputationRequest.INSTANCE.Lower(@value), ref _status)
));
    }

    public static long Factorial(long @num) {
        return FfiConverterInt64.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref RustCallStatus _status) =>
    _UniFFILib.uniffi_dotnet_uniffi_fn_func_factorial(FfiConverterInt64.INSTANCE.Lower(@num), ref _status)
));
    }

    public static String GetFactorial(long @num) {
        return FfiConverterString.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref RustCallStatus _status) =>
    _UniFFILib.uniffi_dotnet_uniffi_fn_func_get_factorial(FfiConverterInt64.INSTANCE.Lower(@num), ref _status)
));
    }

    public static long Last(List<long> @num) {
        return FfiConverterInt64.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref RustCallStatus _status) =>
    _UniFFILib.uniffi_dotnet_uniffi_fn_func_last(FfiConverterSequenceInt64.INSTANCE.Lower(@num), ref _status)
));
    }

    public static int Mul(int @a, int @b) {
        return FfiConverterInt32.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref RustCallStatus _status) =>
    _UniFFILib.uniffi_dotnet_uniffi_fn_func_mul(FfiConverterInt32.INSTANCE.Lower(@a), FfiConverterInt32.INSTANCE.Lower(@b), ref _status)
));
    }

    public static int Sub(int @a, int @b) {
        return FfiConverterInt32.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref RustCallStatus _status) =>
    _UniFFILib.uniffi_dotnet_uniffi_fn_func_sub(FfiConverterInt32.INSTANCE.Lower(@a), FfiConverterInt32.INSTANCE.Lower(@b), ref _status)
));
    }

    public static int Test(int @num) {
        return FfiConverterInt32.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref RustCallStatus _status) =>
    _UniFFILib.uniffi_dotnet_uniffi_fn_func_test(FfiConverterInt32.INSTANCE.Lower(@num), ref _status)
));
    }

    public static void TestPanic() {
        
    _UniffiHelpers.RustCall( (ref RustCallStatus _status) =>
    _UniFFILib.uniffi_dotnet_uniffi_fn_func_test_panic( ref _status)
);
    }

    public static String TestStr(String @num) {
        return FfiConverterString.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref RustCallStatus _status) =>
    _UniFFILib.uniffi_dotnet_uniffi_fn_func_test_str(FfiConverterString.INSTANCE.Lower(@num), ref _status)
));
    }

    public static bool Valid(String @value) {
        return FfiConverterBoolean.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref RustCallStatus _status) =>
    _UniFFILib.uniffi_dotnet_uniffi_fn_func_valid(FfiConverterString.INSTANCE.Lower(@value), ref _status)
));
    }

}

