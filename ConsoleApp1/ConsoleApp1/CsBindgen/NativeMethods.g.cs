// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace CsBindgen
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = "my_dotnet_lib";



        [DllImport(__DllName, EntryPoint = "add_one", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int add_one(int num);

        [DllImport(__DllName, EntryPoint = "alloc_u8_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern RustString alloc_u8_string();

        [DllImport(__DllName, EntryPoint = "free_u8_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void free_u8_string(RustString buffer);

        [DllImport(__DllName, EntryPoint = "get_csharp_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern RustString get_csharp_string(CSharpString cs_string);

        [DllImport(__DllName, EntryPoint = "get_test_mut", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern TestStruct get_test_mut(TestStruct test);

        [DllImport(__DllName, EntryPoint = "get_test_mut_arr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern TestStructArray get_test_mut_arr(TestStructArray test);

        [DllImport(__DllName, EntryPoint = "free_test_arr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void free_test_arr(TestStructArray test);


    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct CSharpString
    {
        public ushort* ptr;
        public int count;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct RustString
    {
        public byte* ptr;
        public int count;
        public int capacity;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct TestStruct
    {
        public int value;
        public int value1;
        public int value2;
        public int value3;
        public int value4;
        public int value5;
        public int value6;
        public int value7;
        public int value8;
        public int value9;
        public int value10;
        public int value11;
        public int value12;
        public int value13;
        public int value14;
        public int value15;
        public int value16;
        public int value17;
        public int value18;
        public int key;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct TestStructArray
    {
        public TestStruct* ptr;
        public int length;
        public int capacity;
    }



}
